\section{Security}

\subsection{Graded DDH}
In this section we instantiate the Graded Decisional Diffie-Hellman assumption for our scheme, introduced in \cite{ggh13a} as the graded encoding scheme analogue of the multilinear decisional Diffie-Hellman assumption in \cite{bs}.  For a full definition of graded encoding schemes, refer to Appendix A.

\begin{definition}[$\kappa$-GDDH]
\label{kgddh}
For a security parameter $\lambda \in \mathbb{N}$ the $\kappa$-Graded Decisional Diffie-Hellman assumption is to distinguish between the distributions $\mathcal{D}_0[(\mathsf{pp}, \pzt)]$ and $D_1[(\mathsf{pp}, \pzt)]$ for $(\mathsf{pp}, \pzt) \leftarrow \mathsf{setup}(1^\lambda, 1^\kappa)$ where: 

$$\mathcal{D}_0[(\mathsf{pp}, \pzt)] = \left\{ \left(\{C_i'\}_{i\in [\kappa + 1]}, \gamma \right) \;\middle|\; \begin{array}{ll}
\forall i \in [\kappa + 1], &  U_i \leftarrow \mathsf{samp}(\mathsf{pp}),\\
& C_i \leftarrow \mathsf{enc}(\mathsf{pp}, 1, U_i)\\
& C_i' \leftarrow \mathsf{rerand}(\mathsf{pp}, C_i)\\
\multicolumn{2}{l}{\gamma \leftarrow \mathsf{ext}(\mathsf{pp}, \pzt, U_{\kappa+1} \cdot\prod_{i \in [\kappa]} C_i)}
\end{array}\right\}$$
and
$$\mathcal{D}_1[(\mathsf{pp}, \pzt)] = \left\{ \left(\{C_i'\}_{i\in [\kappa + 1]}, \gamma \right) \;\middle|\; \begin{array}{ll}
\forall i \in [\kappa + 1], &  U_i \leftarrow \mathsf{samp}(\mathsf{pp}),\\
& C_i \leftarrow \mathsf{enc}(\mathsf{pp}, 1, U_i)\\
& C_i' \leftarrow \mathsf{rerand}(\mathsf{pp}, C_i)\\
\multicolumn{2}{l}{\gamma \leftarrow \{0,1\}^\lambda}
\end{array}\right\}$$
\end{definition}

We conjecture that this problem is hard for our scheme for reasoning given below.

\subsection{Overview}

Let $n$, $q$ and $\chi$ be set such that the RLWE$_{n,q,\chi}$ assumption holds.  Let $\mathcal{D}_\alpha, \mathcal{D}_\delta, \mathcal{D}_\epsilon$ be discrete Gaussian distributions on $\mathbb{Z}^n$ with widths $\sigma_\alpha, \sigma_\delta, \sigma_\epsilon$ respectively, and let $\ell = O(\log q)$.  

The security of our scheme relies on hiding $t$ and $z$; with these parameters an adversary could decrypt an encoding at any level.  We attempt to hide these values through creating RLWE instances with a small ``public key".  However, note that in all of these instances the ``public key" $\alpha$ is not given out like in the canonical RLWE problem.  Thus, the security of the scheme relies on the fact that using the basic operations of the scheme (zero-testing, multiplication, addition), an adversary is only able to produce these RLWE-esque instances.  It is helpful to note that the ``space" of $\flattenfn$ed matrices, our encoding space, only has some properties homomorphically preserved by $\powfn$ vectors, which further restricts the sorts of useful operations that an adversary could perform.  For example, matrix inversion does not work.  To illustrate this with a counterexample, let $q = 5$.  Then: 

\begin{center}
\begin{tabular}{rr}
$X = \left(\begin{array}{ccc}1 & 2 & 3\\ 3 & 2 & 1\\ 1 & 3 & 2\end{array}\right)$ & $\flattenfn(X) = \left(\begin{array}{ccc}0 & 1 & 0\\ 1 & 0 & 0\\ 0 & 0 & 0\end{array}\right)$ \\\\
$X^{-1} = \left(\begin{array}{ccc}3 & 0 & 3\\ 0 & 2 & 4\\ 1 & 2 & 3\end{array}\right)$& $\flattenfn(X^{-1}) = \left(\begin{array}{ccc}0 & 0 & 0\\ 0 & 0 & 0\\ 0 & 1 & 0\end{array}\right)$\\\\
\multicolumn{2}{c}{$\vec{v} = \powfn(1) = \left(\begin{array}{c}1 \\ 2 \\ 4 \end{array}\right)$}
\end{tabular}
\end{center}

Thus giving us: $$\flattenfn(XX^{-1})\cdot\vec{v} = \vec{v} \not= \flattenfn(X)\cdot\flattenfn(X^{-1})\cdot\vec{v} = \left(\begin{array}{c}0 \\ 0 \\ 2 \end{array}\right)$$  While this has some downsides---for example, it prevents us from pre/post-multiplying encodings by a matrix $T$ and its inverse to further randomize encodings and the zero-tester as is done in e.g. a matrix variant of GGH---we would expect it to only reduce the number of possible algebraic attacks.

\subsection{Previous attacks}
It is not hard to see that our construction avoids the zeroizing attacks (\cite{chl}) on the \cite{clt} scheme as our encodings and zero-testing elements simply do not support the right operations for those attacks to work.

The weak-DL attack on GGH and the variant matrix-GGH (\cite{cgh, hj}) worked by attacking the private modulus $g$, which is a small element of the ring $R$.  This fails in our scheme because we do not rely on encodings being small representatives of cosets of $\mathcal{I}_g$---we achieve small encodings (and thus bounded noise growth) through the repeated application of the $\flattenfn$ function, so our ``ideal" is generated by a ``uniform" element, namely, a RLWE instance.  We also have not been able to attack the scheme in the event that $A$ is made public.

Additionally, we may have also reduced the number of potential vulnerabilities by not publishing level-$0$ encodings unlike in e.g. \cite{clt}.

\subsection{Reduction attack on the RLWE ``public key"}

One way the scheme could be attacked is through the search-decision equivalence for RLWE from \cite{lpr}.  That is, if there exists an oracle $\mathcal{O}$ to decide that $(a, b = at+e)$ is drawn from RLWE parameters or from a uniform distribution, then the secret $t$ can be recovered.  In our scheme the zero-testing parameter $\pzt$ would act as such an oracle: an adversary could draw $A' \in \Rq^{N \times 2}$ from a uniform distribution and then multiply $\bdfn(A')$ and $\bdfn(A)$ by $\pzt$.  With high probability the former product will be large and the latter will be small, thus providing the adversary the desired oracle.

This attack does not apply to our scheme because the reduction runs in $\mathsf{poly}(q)$ time, but we need $q > 2^\lambda$ for proper zero-testing.  Additionally, we do not publish $A$ as part of the public parameters.

\subsection{Attacks on the zero-testing element}

We first want to rule out that we cannot get useful information out of the zero-testing element itself.  Note that our zero-testing element looks like the following:
\begin{align*}
\pzt &= \alpha (z^\kappa \vec{v} + \vec{\delta}) + \vec{\epsilon}\\
&= \alpha (z^\kappa \powfn(\vec{s}) + \vec{\delta}) + \vec{\epsilon}\\\\
&= \left( \begin{array}{c}
\alpha (z^\kappa + \delta_1) + \epsilon_1\\
\alpha (z^\kappa2 + \delta_2) + \epsilon_2\\
\vdots \\
\alpha (z^\kappa2^{\ell-1} + \delta_\ell) + \epsilon_\ell\\
-\alpha  (t z^\kappa + \delta_{\ell+1}) + \epsilon_{\ell + 1}\\
\vdots \\
-\alpha (t z^\kappa2^{\ell - 1} + \delta_{2\ell}) + \epsilon_{2\ell}\\
\end{array}\right)
\end{align*}
Thus, we need the following assumption to hold so that we protect the parameters $z^\kappa$ and $t$.  Note that this assumption is very similar to RLWE, except that for each new sample we use a ``small" perturbation of the original secret---if $\delta_i$ was drawn from a uniform distribution, this would reduce to RLWE directly.

\begin{assumption}
\label{rlwevar}
Draw $s \leftarrow \Rq$, $\alpha \leftarrow \mathcal{D}_\alpha$, and $(\delta_i, \epsilon_i) \leftarrow \mathcal{D}_\delta \times \mathcal{D}_\epsilon$ for $i \leq \ell$.  Then from the vector $\vec{p} = \big(\alpha(s + \delta_i) + \epsilon_i\big)_{i=1}^{\ell} \in \Rq^\ell$, recover $s$.
\end{assumption}


\subsection{Getting parameters from zero-tested encodings}

We now draw our attention to using the zero-testing element in breaking the scheme, as is done in all attacks on previous schemes.  A zero-tested encoding at level-$i$ will look like the following, where $\vec{e_{\circ}}$ is the error after some number of operations:

$$C \pzt = \alpha z^{\kappa}(z^{-i} \mu \vec{v} + \vec{e_{\circ}}) + C(\alpha\vec{\delta} + \vec{\epsilon}) \in \Rq^N$$
which we can rewrite as:
$$C\pzt = \alpha (z^{\kappa - i}\mu \vec{v} + \vec{e_{\circ}} + C\vec{\delta}) + C\vec{\epsilon}$$
Thus, we need the following assumption to hold in the case of $i < \kappa$:
\begin{assumption}
\label{rlwevar2}
Draw $s \leftarrow \Rq$, $\alpha \leftarrow \mathcal{D}_\alpha$, and $(\delta_i, \epsilon_i) \leftarrow \mathcal{D}_\delta \times \mathcal{D}_\epsilon$ for $i \leq \ell$.  Then from the vector $\vec{p} = \big(\alpha s \delta_i + \epsilon_i)_{i=1}^{\ell} \in \Rq^\ell$, recover $s$.\\
\end{assumption}

In the case of $\mu = 0$ we have:
\begin{equation}\label{eq:topleveltested}
C\pzt = \alpha (\vec{e_{\circ}} + C\vec{\delta}) + C\vec{\epsilon}
\end{equation}
So the following assumption also needs to hold:
\begin{assumption}
\label{rlwevar3}
Draw $\alpha \leftarrow \mathcal{D}_\alpha$, and $(\delta_i, \epsilon_i) \leftarrow \mathcal{D}_\delta \times \mathcal{D}_\epsilon$ for $i \leq \ell$.  Then from the vector $\vec{p} = \big(\alpha \delta_i + \epsilon_i\big)_{i=1}^{\ell} \in \Rq^\ell$, recover $\epsilon_i$.\\
\end{assumption}

\subsection{Some additional notes}

Though none of our assumptions reduce directly to RLWE and nor does the entire scheme's security reduce to any of our variants, we remain confident in the scheme's security based on the fact that the application of the zero-testing parameter only produces instances of these RLWE variants that we presume to be hard.  That is, encodings of $0$ at any level do not seem to present a problem as in previous work.  Additionally, although we take the precaution of hiding the parameters $A$ and $\alpha$, we have not been able to break the scheme in the case that they are made public. 
